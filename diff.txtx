diff --git a/add_copyright.sh b/add_copyright.sh
index 996b486..ab37544 100755
--- a/add_copyright.sh
+++ b/add_copyright.sh
@@ -42,7 +42,7 @@ process_file() {
     cp "$TEMP_FILE" "$file"
 }
 
-find . -type f \( -name "*.c" -o -name "*.h" \) | while read -r file; do
+find . -type f \( -name "*.c" -o -name "*.h" -o -name "*.s" \) | while read -r file; do
     process_file "$file"
 done
 
diff --git a/src/Makefile b/src/Makefile
index 6f7d21b..013f5eb 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -4,7 +4,7 @@ AS = nasm
 QEMU = qemu-system-x86_64
 QEMU_GUI_OPTS = -display gtk
 
-CFLAGS = -m64 -ffreestanding -fno-pic -fno-stack-protector -g -O0 -mno-red-zone -mcmodel=kernel -mno-sse -mno-mmx -mno-sse2 -mno-avx -mno-80387 -I.
+CFLAGS = -m64 -ffreestanding -fno-pic -fstack-protector-strong -g -O0 -mno-red-zone -mcmodel=kernel -mno-sse -mno-mmx -mno-sse2 -mno-avx -mno-80387 -I.
 LDFLAGS = -m elf_x86_64 -T linker.ld -Map=../bin/kernel.map
 
 KERNEL_BIN = ../bin/kernel.bin
@@ -46,10 +46,12 @@ ELF_O = ../bin/elf.o
 USERSPACE_O = ../bin/userspace.o
 USERSPACE_ASM_O = ../bin/userspace_asm.o
 SYSCALL_ASM_O = ../bin/syscall_asm.o
+USERADDR_O = ../bin/useraddr.o
+SCHEDULER_O = ../bin/scheduler.o
 
 OBJ = $(BOOT_O) $(KERNEL_O) $(STRING_O) $(ITOA_O) $(HARDWARE_O) $(COM1_O) $(IDT_ASM_O) $(IDT_C_O) $(PIC_O) \
       $(HANDLERS_O) $(PANIC_O) $(MEMORY_O) $(PATA_O) $(CHAINFS_O) $(VGA_O) $(PS2_O) $(KEYBOARD_O) $(FB_O) $(FONT_O) $(TIMER_O) $(STDLIB_O) $(MMU_O) $(WRITE_O) $(READ_O) $(OPEN_O) $(CLOSE_O) $(SYSCALL_O) \
-      $(GDT_O) $(GDT_ASM_O) $(PROCESS_O) $(ELF_O) $(USERSPACE_O) $(USERSPACE_ASM_O) $(SYSCALL_ASM_O)
+      $(GDT_O) $(GDT_ASM_O) $(PROCESS_O) $(ELF_O) $(USERSPACE_O) $(USERSPACE_ASM_O) $(SYSCALL_ASM_O) $(USERADDR_O) $(SCHEDULER_O)
 
 all: $(ISO_IMAGE)
 
@@ -184,6 +186,14 @@ $(PROCESS_O): kernel/process.c
 	@echo "  CC      $<"
 	@$(CC) $(CFLAGS) -c $< -o $@
 
+$(USERADDR_O): kernel/useraddr.c kernel/useraddr.h
+	@echo "  CC      $<"
+	@$(CC) $(CFLAGS) -c $< -o $@
+
+$(SCHEDULER_O): kernel/scheduler.c kernel/scheduler.h kernel/process.h kernel/mmu.h kernel/gdt.h kernel/interrupts/idt.h
+	@echo "  CC      $<"
+	@$(CC) $(CFLAGS) -c $< -o $@
+
 $(ELF_O): userland/elf.c
 	@echo "  CC      $<"
 	@$(CC) $(CFLAGS) -c $< -o $@
diff --git a/src/boot/boot.s b/src/boot/boot.s
index e826a14..a5bc6f9 100644
--- a/src/boot/boot.s
+++ b/src/boot/boot.s
@@ -1,3 +1,28 @@
+/*
+ * Copyright (c) 2026, otsos team
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
 .intel_syntax noprefix
 
 /*
diff --git a/src/kernel/drivers/keyboard/keyboard.c b/src/kernel/drivers/keyboard/keyboard.c
index 9863e59..8ce1f73 100644
--- a/src/kernel/drivers/keyboard/keyboard.c
+++ b/src/kernel/drivers/keyboard/keyboard.c
@@ -79,6 +79,14 @@ char keyboard_getchar() {
   return c;
 }
 
+char keyboard_getchar_blocking() {
+  char c = 0;
+  while ((c = keyboard_getchar()) == 0) {
+    __asm__ volatile("hlt");
+  }
+  return c;
+}
+
 void keyboard_common_handler() {
   if (current_driver && current_driver->handler) {
     current_driver->handler();
diff --git a/src/kernel/drivers/keyboard/keyboard.h b/src/kernel/drivers/keyboard/keyboard.h
index 68ad654..f40584b 100644
--- a/src/kernel/drivers/keyboard/keyboard.h
+++ b/src/kernel/drivers/keyboard/keyboard.h
@@ -42,6 +42,7 @@ typedef struct {
 
 void keyboard_manager_init();
 char keyboard_getchar();
+char keyboard_getchar_blocking();
 void keyboard_common_handler();
 void keyboard_poll();
 int scanf(const char *format, ...);
diff --git a/src/kernel/gdt.asm b/src/kernel/gdt.asm
index 8b9cb43..3900b7f 100644
--- a/src/kernel/gdt.asm
+++ b/src/kernel/gdt.asm
@@ -1,3 +1,4 @@
+
 [bits 64]
 
 ; GDT segment selectors
diff --git a/src/kernel/interrupts/handlers.c b/src/kernel/interrupts/handlers.c
index dbca990..22c9331 100644
--- a/src/kernel/interrupts/handlers.c
+++ b/src/kernel/interrupts/handlers.c
@@ -27,6 +27,7 @@
 #include <kernel/drivers/keyboard/keyboard.h>
 #include <kernel/drivers/timer.h>
 #include <kernel/interrupts/idt.h>
+#include <kernel/scheduler.h>
 #include <mlibc/mlibc.h>
 
 extern void kernel_panic(registers_t *regs);
@@ -67,6 +68,7 @@ void isr_handler(registers_t *regs) {
 void irq_handler(registers_t *regs) {
   if (regs->int_no == 32) {
     timer_handler();
+    scheduler_tick(regs);
     keyboard_poll();
   } else if (regs->int_no == 33) {
     keyboard_common_handler();
diff --git a/src/kernel/interrupts/idt.asm b/src/kernel/interrupts/idt.asm
index 3f5a0ec..da7398d 100644
--- a/src/kernel/interrupts/idt.asm
+++ b/src/kernel/interrupts/idt.asm
@@ -1,3 +1,4 @@
+
 [bits 64]
 extern isr_handler
 extern irq_handler
diff --git a/src/kernel/mmu.c b/src/kernel/mmu.c
index 9692133..25f85cd 100644
--- a/src/kernel/mmu.c
+++ b/src/kernel/mmu.c
@@ -28,7 +28,26 @@
 #include <lib/com1.h>
 #include <mlibc/memory.h>
 
+#define MSR_EFER 0xC0000080
+#define EFER_NXE (1ULL << 11)
+
+static inline void mmu_wrmsr(u32 msr, u64 value) {
+  u32 low = value & 0xFFFFFFFF;
+  u32 high = value >> 32;
+  __asm__ volatile("wrmsr" : : "c"(msr), "a"(low), "d"(high));
+}
+
+static inline u64 mmu_rdmsr(u32 msr) {
+  u32 low, high;
+  __asm__ volatile("rdmsr" : "=a"(low), "=d"(high) : "c"(msr));
+  return ((u64)high << 32) | low;
+}
+
 void mmu_init() {
+  u64 efer = mmu_rdmsr(MSR_EFER);
+  if (!(efer & EFER_NXE)) {
+    mmu_wrmsr(MSR_EFER, efer | EFER_NXE);
+  }
   u64 cr3 = mmu_read_cr3();
   com1_printf("[MMU] Initialized. Current CR3: %p\n", (void *)cr3);
 }
diff --git a/src/kernel/posix/read.c b/src/kernel/posix/read.c
index d706b22..486d8da 100644
--- a/src/kernel/posix/read.c
+++ b/src/kernel/posix/read.c
@@ -28,6 +28,7 @@
 #include <kernel/drivers/keyboard/keyboard.h>
 #include <kernel/drivers/vga.h>
 #include <kernel/posix/posix.h>
+#include <kernel/useraddr.h>
 #include <lib/com1.h>
 #include <mlibc/mlibc.h>
 
@@ -45,15 +46,20 @@ int sys_read(int fd, void *buf, u32 count) {
     return 0;
   }
 
+  if (!is_user_address(buf, count)) {
+    com1_printf("[DEBUG] sys_read: invalid user buffer %p (%d)\n", buf,
+                (int)count);
+    return -1;
+  }
+
   char *data = (char *)buf;
 
   if (fd == STDIN_FILENO) {
     __asm__ volatile("sti");
     u32 i = 0;
     while (i < count) {
-      char c = keyboard_getchar();
+      char c = keyboard_getchar_blocking();
       if (c == 0) {
-        __asm__ volatile("hlt");
         continue;
       }
 
diff --git a/src/kernel/posix/write.c b/src/kernel/posix/write.c
index 922baa9..c80f349 100644
--- a/src/kernel/posix/write.c
+++ b/src/kernel/posix/write.c
@@ -27,6 +27,7 @@
 #include <kernel/drivers/fs/chainFS/chainfs.h>
 #include <kernel/drivers/vga.h>
 #include <kernel/posix/posix.h>
+#include <kernel/useraddr.h>
 #include <lib/com1.h>
 #include <mlibc/memory.h>
 #include <mlibc/mlibc.h>
@@ -58,6 +59,10 @@ int sys_write(int fd, const void *buf, u32 count) {
     return 0;
   }
 
+  if (!is_user_address(buf, count)) {
+    return -1;
+  }
+
   const char *data = (const char *)buf;
 
   if (fd == STDOUT_FILENO || fd == STDERR_FILENO) {
diff --git a/src/kernel/process.c b/src/kernel/process.c
index ec53f5e..04a397c 100644
--- a/src/kernel/process.c
+++ b/src/kernel/process.c
@@ -28,6 +28,7 @@
 #include <kernel/mmu.h>
 #include <kernel/panic.h>
 #include <kernel/process.h>
+#include <kernel/signal.h>
 #include <lib/com1.h>
 #include <mlibc/memory.h>
 
@@ -124,6 +125,18 @@ void process_set_current(process_t *proc) {
   }
 }
 
+void process_switch(process_t *proc) {
+  if (!proc) {
+    return;
+  }
+  process_set_current(proc);
+  mmu_write_cr3(proc->cr3);
+}
+
+void process_yield(void) {
+  __asm__ volatile("int $32");
+}
+
 void process_exit(int code) {
   if (!current_process) {
     com1_printf("[PROC] Error: No current process to exit\n");
@@ -200,3 +213,29 @@ int process_kill(u32 pid) {
 
   return 0;
 }
+
+int process_send_signal(u32 pid, int sig) {
+  if (sig == 0) {
+    sig = SIGKILL;
+  }
+
+  if (sig != SIGKILL && sig != SIGTERM) {
+    return -1;
+  }
+
+  process_t *proc = process_get(pid);
+  if (!proc) {
+    return -1;
+  }
+
+  if (sig == SIGTERM) {
+    proc->exit_code = 128 + sig;
+  }
+
+  if (proc == current_process) {
+    process_exit(proc->exit_code ? proc->exit_code : -1);
+    return 0;
+  }
+
+  return process_kill(pid);
+}
diff --git a/src/kernel/process.h b/src/kernel/process.h
index ccfa66f..a8d4c60 100644
--- a/src/kernel/process.h
+++ b/src/kernel/process.h
@@ -101,6 +101,7 @@ void process_set_current(process_t *proc);
 /* Exit current process */
 void process_exit(int code);
 int process_kill(u32 pid);
+int process_send_signal(u32 pid, int sig);
 
 /* Switch to a process (used by scheduler) */
 void process_switch(process_t *proc);
diff --git a/src/kernel/syscall.c b/src/kernel/syscall.c
index a33bafd..8c0d418 100644
--- a/src/kernel/syscall.c
+++ b/src/kernel/syscall.c
@@ -96,7 +96,7 @@ void syscall_handler(registers_t *regs) {
     process_exit((int)arg1);
     break;
   case SYS_KILL:
-    regs->rax = process_kill((u32)arg1);
+    regs->rax = process_send_signal((u32)arg1, (int)arg2);
     break;
   default:
     com1_printf("Unknown syscall: %d\n", syscall_number);
diff --git a/src/kernel/syscall_asm.asm b/src/kernel/syscall_asm.asm
index 459a3e2..4ea0c57 100644
--- a/src/kernel/syscall_asm.asm
+++ b/src/kernel/syscall_asm.asm
@@ -1,3 +1,5 @@
+
+
 [BITS 64]
 
 section .text
diff --git a/src/lib/com1.s b/src/lib/com1.s
index 45ef20a..c572b02 100644
--- a/src/lib/com1.s
+++ b/src/lib/com1.s
@@ -1,3 +1,4 @@
+
 [bits 16]
 
 
diff --git a/src/mlibc/hardware.asm b/src/mlibc/hardware.asm
index d570c1a..aa5b553 100644
--- a/src/mlibc/hardware.asm
+++ b/src/mlibc/hardware.asm
@@ -1,3 +1,4 @@
+
 section .text
 global inb
 inb:
diff --git a/src/mlibc/itoa.s b/src/mlibc/itoa.s
index 60f76c2..45854b8 100644
--- a/src/mlibc/itoa.s
+++ b/src/mlibc/itoa.s
@@ -1,3 +1,28 @@
+/*
+ * Copyright (c) 2026, otsos team
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
 	.file	"itoa.c"
 	.intel_syntax noprefix
 	.text
diff --git a/src/mlibc/memory.c b/src/mlibc/memory.c
index 62afa03..514dbee 100644
--- a/src/mlibc/memory.c
+++ b/src/mlibc/memory.c
@@ -31,6 +31,9 @@
 extern char kernel_end;
 #define HEAP_SIZE (8 * 1024 * 1024)
 #define HEAP_MAGIC 0x48454150
+#define HEAP_REDZONE_SIZE 16
+#define HEAP_REDZONE_PATTERN 0xCC
+#define HEAP_POISON_PATTERN 0xAA
 
 static char *heap_start = 0;
 static char *heap_end = 0;
@@ -39,6 +42,7 @@ typedef struct header {
   unsigned int magic;
   unsigned int is_free;
   unsigned long size;
+  unsigned long payload_size;
   struct header *next;
   struct header *prev;
 } header_t;
@@ -53,6 +57,7 @@ static void split_block(header_t *current, unsigned long size) {
         (header_t *)((char *)current + sizeof(header_t) + size);
     new_block->magic = HEAP_MAGIC;
     new_block->size = current->size - size - sizeof(header_t);
+    new_block->payload_size = 0;
     new_block->is_free = 1;
     new_block->next = current->next;
     new_block->prev = current;
@@ -73,6 +78,7 @@ static header_t *coalesce(header_t *block) {
   header_t *next = block->next;
   if (next && next->is_free && next->magic == HEAP_MAGIC) {
     block->size += sizeof(header_t) + next->size;
+    block->payload_size = 0;
     block->next = next->next;
     if (block->next) {
       block->next->prev = block;
@@ -82,6 +88,7 @@ static header_t *coalesce(header_t *block) {
   header_t *prev = block->prev;
   if (prev && prev->is_free && prev->magic == HEAP_MAGIC) {
     prev->size += sizeof(header_t) + block->size;
+    prev->payload_size = 0;
     prev->next = block->next;
     if (block->next) {
       block->next->prev = prev;
@@ -100,6 +107,7 @@ void init_heap() {
   heap_head = (header_t *)heap_start;
   heap_head->magic = HEAP_MAGIC;
   heap_head->size = HEAP_SIZE - sizeof(header_t);
+  heap_head->payload_size = 0;
   heap_head->next = 0;
   heap_head->prev = 0;
   heap_head->is_free = 1;
@@ -117,6 +125,8 @@ void *kmalloc(unsigned long size) {
     return 0;
 
   size = align16(size);
+  unsigned long payload_size = size;
+  unsigned long total_size = payload_size + (2 * HEAP_REDZONE_SIZE);
 
   header_t *current = heap_head;
   while (current) {
@@ -125,10 +135,15 @@ void *kmalloc(unsigned long size) {
                   current->magic);
       return 0;
     }
-    if (current->is_free && current->size >= size) {
-      split_block(current, size);
+    if (current->is_free && current->size >= total_size) {
+      split_block(current, total_size);
       current->is_free = 0;
-      return (void *)((char *)current + sizeof(header_t));
+      current->payload_size = payload_size;
+      u8 *base = (u8 *)current + sizeof(header_t);
+      memset(base, HEAP_REDZONE_PATTERN, HEAP_REDZONE_SIZE);
+      memset(base + HEAP_REDZONE_SIZE + payload_size, HEAP_REDZONE_PATTERN,
+             HEAP_REDZONE_SIZE);
+      return (void *)(base + HEAP_REDZONE_SIZE);
     }
     current = current->next;
   }
@@ -143,7 +158,8 @@ void kfree(void *ptr) {
   if (!heap_start || !heap_end)
     return;
 
-  header_t *header = (header_t *)((char *)ptr - sizeof(header_t));
+  header_t *header =
+      (header_t *)((char *)ptr - HEAP_REDZONE_SIZE - sizeof(header_t));
 
   if ((char *)header < heap_start || (char *)header >= heap_end) {
     com1_printf("KFREE: invalid pointer %p\n", ptr);
@@ -160,6 +176,24 @@ void kfree(void *ptr) {
     return;
   }
 
+  u8 *base = (u8 *)header + sizeof(header_t);
+  u8 *payload = base + HEAP_REDZONE_SIZE;
+  for (u32 i = 0; i < HEAP_REDZONE_SIZE; i++) {
+    if (base[i] != HEAP_REDZONE_PATTERN) {
+      com1_printf("KFREE: left redzone corrupted at %p\n", ptr);
+      break;
+    }
+  }
+  for (u32 i = 0; i < HEAP_REDZONE_SIZE; i++) {
+    if (payload[header->payload_size + i] != HEAP_REDZONE_PATTERN) {
+      com1_printf("KFREE: right redzone corrupted at %p\n", ptr);
+      break;
+    }
+  }
+
+  memset(payload, HEAP_POISON_PATTERN, header->payload_size);
+
+  header->payload_size = 0;
   header->is_free = 1;
   coalesce(header);
 }
@@ -188,19 +222,21 @@ void *krealloc(void *ptr, unsigned long size) {
   if (header->magic != HEAP_MAGIC)
     return 0;
 
-  if (header->size >= size) {
+  if (header->payload_size >= size) {
     return ptr;
   }
 
   header_t *next = header->next;
   if (next && next->is_free &&
-      (header->size + sizeof(header_t) + next->size) >= size) {
+      (header->size + sizeof(header_t) + next->size) >=
+          (align16(size) + (2 * HEAP_REDZONE_SIZE))) {
     header->size += sizeof(header_t) + next->size;
     header->next = next->next;
     if (header->next) {
       header->next->prev = header;
     }
-    split_block(header, align16(size));
+    header->payload_size = align16(size);
+    split_block(header, header->payload_size + (2 * HEAP_REDZONE_SIZE));
     return ptr;
   }
 
@@ -208,7 +244,7 @@ void *krealloc(void *ptr, unsigned long size) {
   if (!new_ptr)
     return 0;
 
-  memcpy(new_ptr, ptr, header->size);
+  memcpy(new_ptr, ptr, header->payload_size);
   kfree(ptr);
   return new_ptr;
 }
@@ -251,26 +287,26 @@ void *kmalloc_aligned(unsigned long size, unsigned long align) {
   if (align <= 16)
     return kmalloc(size);
 
-  size = align16(size);
+  unsigned long payload_size = align16(size);
+  unsigned long total_size = payload_size + (2 * HEAP_REDZONE_SIZE);
   header_t *current = heap_head;
 
   while (current) {
     if (current->is_free) {
-      unsigned long data_start = (unsigned long)current + sizeof(header_t);
-      unsigned long aligned_start = (data_start + align - 1) & ~(align - 1);
-      unsigned long padding = aligned_start - data_start;
-
-      if (current->size >= size + padding) {
-        // If we need padding, we might need to split the block twice:
-        // 1. One split to create a block before the aligned part (if padding is
-        // enough for a header)
-        // 2. Normal split for the tail after the requested size.
-
+      unsigned long data_start =
+          (unsigned long)current + sizeof(header_t) + HEAP_REDZONE_SIZE;
+      unsigned long aligned_payload = (data_start + align - 1) & ~(align - 1);
+      unsigned long aligned_header =
+          aligned_payload - HEAP_REDZONE_SIZE - sizeof(header_t);
+      unsigned long padding = aligned_header - (unsigned long)current;
+
+      if (padding + total_size <= current->size) {
         if (padding >= sizeof(header_t) + 16) {
           header_t *aligned_block = (header_t *)((char *)current + padding);
           aligned_block->magic = HEAP_MAGIC;
           aligned_block->is_free = 1;
           aligned_block->size = current->size - padding;
+          aligned_block->payload_size = 0;
           aligned_block->next = current->next;
           aligned_block->prev = current;
 
@@ -279,15 +315,24 @@ void *kmalloc_aligned(unsigned long size, unsigned long align) {
 
           current->next = aligned_block;
           current->size = padding - sizeof(header_t);
+          current->payload_size = 0;
 
           current = aligned_block;
           padding = 0;
+        } else if (padding != 0) {
+          current = current->next;
+          continue;
         }
 
         if (padding == 0) {
-          split_block(current, size);
+          split_block(current, total_size);
           current->is_free = 0;
-          return (void *)((char *)current + sizeof(header_t));
+          current->payload_size = payload_size;
+          u8 *base = (u8 *)current + sizeof(header_t);
+          memset(base, HEAP_REDZONE_PATTERN, HEAP_REDZONE_SIZE);
+          memset(base + HEAP_REDZONE_SIZE + current->payload_size,
+                 HEAP_REDZONE_PATTERN, HEAP_REDZONE_SIZE);
+          return (void *)(base + HEAP_REDZONE_SIZE);
         }
       }
     }
@@ -302,8 +347,9 @@ void *kmalloc_aligned(unsigned long size, unsigned long align) {
 unsigned long kmalloc_usable_size(void *ptr) {
   if (!ptr)
     return 0;
-  header_t *header = (header_t *)((char *)ptr - sizeof(header_t));
+  header_t *header =
+      (header_t *)((char *)ptr - HEAP_REDZONE_SIZE - sizeof(header_t));
   if (header->magic != HEAP_MAGIC)
     return 0;
-  return header->size;
+  return header->payload_size;
 }
diff --git a/src/mlibc/mlibc.h b/src/mlibc/mlibc.h
index de89ed2..13ab474 100644
--- a/src/mlibc/mlibc.h
+++ b/src/mlibc/mlibc.h
@@ -35,6 +35,7 @@ typedef unsigned char u8;
 typedef unsigned short u16;
 typedef unsigned int u32;
 typedef unsigned long long u64;
+typedef unsigned long size_t;
 
 typedef signed char s8;
 typedef signed short s16;
@@ -61,4 +62,4 @@ void outsw(unsigned short port, void *addr, unsigned long count);
 #include <mlibc/memory.h>
 #include <mlibc/stdlib.h>
 
-#endif
\ No newline at end of file
+#endif
diff --git a/src/mlibc/stdlib.c b/src/mlibc/stdlib.c
index 2ede6ff..a1a185b 100644
--- a/src/mlibc/stdlib.c
+++ b/src/mlibc/stdlib.c
@@ -25,8 +25,19 @@
  */
 
 #include <kernel/drivers/timer.h>
+#include <lib/com1.h>
 #include <mlibc/stdlib.h>
 
+u64 __stack_chk_guard = 0x595e9fbd94fda766ULL;
+
+__attribute__((noreturn)) void __stack_chk_fail(void) {
+  com1_write_string("[STACK] stack smashing detected\n");
+  __asm__ volatile("cli");
+  while (1) {
+    __asm__ volatile("hlt");
+  }
+}
+
 void sleep(u32 ms) {
   u64 start_ticks = timer_get_ticks();
   while (timer_get_ticks() < start_ticks + ms) {
diff --git a/src/userland/elf.c b/src/userland/elf.c
index 4529067..09b4153 100644
--- a/src/userland/elf.c
+++ b/src/userland/elf.c
@@ -160,6 +160,9 @@ u64 elf_load(void *data, u64 size) {
     if (phdr->p_flags & PF_W) {
       page_flags |= PTE_RW;
     }
+    if (!(phdr->p_flags & PF_X)) {
+      page_flags |= PTE_NX;
+    }
 
     /* Map pages for this segment */
     u64 page_start = vaddr & ~(PAGE_SIZE - 1);
diff --git a/src/userland/userspace.asm b/src/userland/userspace.asm
index 03d1f9a..928d9bf 100644
--- a/src/userland/userspace.asm
+++ b/src/userland/userspace.asm
@@ -1,3 +1,5 @@
+
+
 [bits 64]
 
 ; Segment selectors for Ring 3
diff --git a/src/userland/userspace.c b/src/userland/userspace.c
index 0f06232..a60a199 100644
--- a/src/userland/userspace.c
+++ b/src/userland/userspace.c
@@ -62,7 +62,7 @@ static u64 allocate_user_stack(void) {
     memset(page, 0, PAGE_SIZE);
 
     u64 vaddr = stack_bottom + (i * PAGE_SIZE);
-    mmu_map_page(vaddr, (u64)page, PTE_PRESENT | PTE_RW | PTE_USER);
+    mmu_map_page(vaddr, (u64)page, PTE_PRESENT | PTE_RW | PTE_USER | PTE_NX);
   }
 
   /* Return top of stack (stack grows downward) */
